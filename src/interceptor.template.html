<script>
  console.log('[Standalone Archiver] Offline Interceptor Active');
  window.__URL_MAP__ = {{URL_MAP_PLACEHOLDER}};

  function findLocalMap(requestUrl) {
      if(!requestUrl) return null;
      const keys = Object.keys(window.__URL_MAP__);
      if (window.__URL_MAP__[requestUrl]) return window.__URL_MAP__[requestUrl];
      try {
          const reqUrlObj = new URL(requestUrl, window.location.origin);
          const reqPathname = reqUrlObj.pathname;
          for (let key of keys) {
              try {
                  if (new URL(key).pathname === reqPathname) return window.__URL_MAP__[key];
              } catch(e) {}
          }
      } catch(e) {}
      let searchStr = requestUrl.split('?')[0];
      for(let key of keys) {
          if(key.split('?')[0].endsWith(searchStr)) return window.__URL_MAP__[key];
      }
      return null;
  }

  const originalFetch = window.fetch;
  window.fetch = async function() {
      let urlStr = typeof arguments[0] === 'string' ? arguments[0] : arguments[0].url;
      let localPath = findLocalMap(urlStr);
      // Standalone uses relative paths from the current HTML file
      if (localPath) arguments[0] = './' + localPath;
      return originalFetch.apply(this, arguments);
  };

  const originalOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url, ...rest) {
      let localPath = findLocalMap(url.toString());
      if (localPath) url = './' + localPath;
      return originalOpen.call(this, method, url, ...rest);
  };

  const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && ['src', 'srcset', 'href'].includes(mutation.attributeName)) {
              const el = mutation.target;
              const currentVal = el.getAttribute(mutation.attributeName);
              // Prevent infinite loops by ignoring data URIs and already-rewritten relative paths
              if (!currentVal || currentVal.startsWith('data:') || currentVal.startsWith('./')) return;

              let localPath = findLocalMap(currentVal);
              if (localPath) {
                  observer.disconnect();
                  if (mutation.attributeName === 'srcset') {
                      el.setAttribute('srcset', currentVal.split(',').map(part => {
                          const p = part.trim().split(/\s+/);
                          let lp = findLocalMap(p[0]);
                          return lp ? './' + lp + (p[1] ? ' ' + p[1] : '') : part;
                      }).join(', '));
                  } else {
                      el.setAttribute(mutation.attributeName, './' + localPath);
                  }
                  startObserving();
              }
          }

          if (mutation.type === 'childList') {
              mutation.addedNodes.forEach(node => {
                  if (node.nodeType === 1) {
                      const processNode = (el) => {
                          ['src', 'href'].forEach(attr => {
                              if (el.hasAttribute && el.hasAttribute(attr)) {
                                  const val = el.getAttribute(attr);
                                  if (val && !val.startsWith('data:') && !val.startsWith('./')) {
                                      let local = findLocalMap(val);
                                      if (local) {
                                          observer.disconnect();
                                          el.setAttribute(attr, './' + local);
                                          startObserving();
                                      }
                                  }
                              }
                          });
                      };

                      processNode(node);
                      if (node.querySelectorAll) {
                          node.querySelectorAll('[src], [href]').forEach(processNode);
                      }
                  }
              });
          }
      });
  });

  function startObserving() {
      if(!document.documentElement) return;
      observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: ['src', 'srcset', 'href'] });
  }

  startObserving();
  window.addEventListener('DOMContentLoaded', startObserving);
</script>
